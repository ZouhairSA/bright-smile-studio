\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Rapport Expert Bright Smile Studio},
    pdfauthor={Jihane Ouaanda}
}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{shapes,arrows,positioning,decorations.pathreplacing}
\usepackage{fontawesome5}
\usepackage{amsmath}
\usepackage{amssymb}

% Configuration des couleurs pour le code
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{primaryblue}{RGB}{14,165,233}
\definecolor{secondaryblue}{RGB}{59,130,246}

% Configuration de listings pour PHP
\lstdefinestyle{phpstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=PHP
}

% Configuration de listings pour SQL
\lstdefinestyle{sqlstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{red},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=SQL
}

% Configuration de listings pour JavaScript/TypeScript
\lstdefinestyle{jsstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{red},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=JavaScript
}

% En-têtes et pieds de page
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textcolor{primaryblue}{\textbf{Bright Smile Studio}}}
\fancyhead[R]{\textcolor{secondaryblue}{\thepage}}
\fancyfoot[C]{\textcolor{gray}{Rapport Technique - \today}}

% Formatage des titres
\titleformat{\section}
{\Large\bfseries\color{primaryblue}}
{\thesection}{1em}{}

\titleformat{\subsection}
{\large\bfseries\color{secondaryblue}}
{\thesubsection}{1em}{}

\titleformat{\subsubsection}
{\normalsize\bfseries\color{blue!60!black}}
{\thesubsubsection}{1em}{}

\begin{document}

% Page de titre
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    {\Huge\bfseries\color{primaryblue} Bright Smile Studio\par}
    \vspace{0.5cm}
    {\Large\color{secondaryblue} Application Web de Gestion de Cabinet Dentaire\par}
    \vspace{1cm}
    
    \begin{figure}[h]
        \centering
        \framebox[0.3\textwidth]{\parbox{0.25\textwidth}{\centering \faTooth[regular]\\[1.5cm] Logo}}
    \end{figure}
    
    \vspace{2cm}
    
    {\large\bfseries Rapport Technique Complet\par}
    \vspace{1.5cm}
    
    {\large
    \begin{tabular}{ll}
        \faUser[regular] \textbf{Auteur :} & Jihane Ouaanda \\
        \faCalendar[regular] \textbf{Date :} & \today \\
        \faCode[regular] \textbf{Projet :} & Application Web Full-Stack \\
        \faDatabase[regular] \textbf{Base de données :} & MySQL/MariaDB \\
    \end{tabular}
    }
    
    \vfill
    
    {\large \faUniversity[regular] Université / École\par}
    {\large Année Académique 2024-2025\par}
    
    \vspace{1cm}
    
    {\small \faInfoCircle[regular] Document technique détaillé - Version 1.0\par}
\end{titlepage}

\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage
\listoflistings

\newpage
\section{Introduction Générale}

\subsection{Contexte et Motivation du Projet}

Bright Smile Studio représente une solution web moderne et complète développée spécifiquement pour répondre aux besoins de gestion d'un cabinet dentaire contemporain. Dans un contexte où la digitalisation des services de santé devient essentielle, cette application permet de moderniser les interactions entre le cabinet et ses patients tout en optimisant la gestion administrative quotidienne.

Le projet s'inscrit dans une démarche d'amélioration de l'expérience patient et d'efficacité opérationnelle. Les cabinets dentaires modernes nécessitent des outils qui permettent aux patients de prendre rendez-vous facilement, de consulter leur historique, et aux administrateurs de gérer efficacement les plannings, les contacts et les données patients.

\subsection{Objectifs Stratégiques}

Les objectifs du projet peuvent être catégorisés en plusieurs dimensions :

\subsubsection{Objectifs Fonctionnels}

\begin{enumerate}
    \item \textbf{Gestion des Rendez-vous} : Permettre aux patients de prendre rendez-vous en ligne 24/7, avec sélection de date, heure et service souhaité
    \item \textbf{Historique Personnel} : Offrir à chaque patient un accès complet à son historique de rendez-vous basé sur son adresse email
    \item \textbf{Authentification Sécurisée} : Système d'inscription et de connexion robuste avec gestion des rôles (patient/admin)
    \item \textbf{Interface Administrative} : Tableau de bord complet pour gérer utilisateurs, rendez-vous et messages de contact
    \item \textbf{Communication} : Formulaire de contact permettant aux visiteurs de communiquer avec le cabinet
\end{enumerate}

\subsubsection{Objectifs Techniques}

\begin{itemize}
    \item Architecture modulaire et maintenable
    \item Sécurité renforcée (hashage de mots de passe, requêtes préparées, validation des données)
    \item Performance optimale avec chargement asynchrone des données
    \item Interface responsive adaptée à tous les appareils
    \item Code propre et documenté pour faciliter la maintenance
\end{itemize}

\subsubsection{Objectifs Utilisateur}

\begin{itemize}
    \item Expérience utilisateur fluide et intuitive
    \item Interface moderne et professionnelle
    \item Accès rapide aux informations importantes
    \item Transparence totale sur l'historique des rendez-vous
\end{itemize}

\subsection{Portée du Projet}

Le projet couvre l'ensemble du cycle de vie d'un rendez-vous dentaire, depuis la prise de rendez-vous initiale jusqu'à la consultation de l'historique, en passant par la gestion administrative complète. L'application s'adresse à deux types d'utilisateurs principaux :

\begin{description}
    \item[\faUser[regular] Patients] : Utilisateurs finaux qui prennent rendez-vous et consultent leur historique
    \item[\faUserShield[regular] Administrateurs] : Personnel du cabinet qui gère les rendez-vous, les utilisateurs et les contacts
\end{description}

\subsection{Technologies et Outils Utilisés}

\subsubsection{Stack Frontend}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Technologie} & \textbf{Version} & \textbf{Rôle} \\
\hline
React & 18.3.1 & Bibliothèque UI principale \\
\hline
TypeScript & 5.8.3 & Typage statique pour JavaScript \\
\hline
Vite & 5.4.19 & Build tool et serveur de développement \\
\hline
React Router DOM & 6.30.1 & Routage côté client \\
\hline
Tailwind CSS & 3.4.17 & Framework CSS utilitaire \\
\hline
shadcn/ui & Latest & Composants UI modernes \\
\hline
React Hook Form & 7.61.1 & Gestion de formulaires \\
\hline
Zod & 3.25.76 & Validation de schémas \\
\hline
TanStack Query & 5.83.0 & Gestion d'état serveur \\
\hline
Lucide React & 0.462.0 & Bibliothèque d'icônes \\
\hline
\end{tabular}
\caption{Technologies Frontend utilisées}
\end{table}

\subsubsection{Stack Backend}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Technologie} & \textbf{Version} & \textbf{Rôle} \\
\hline
PHP & 8.2+ & Langage de programmation serveur \\
\hline
PDO & Built-in & Interface d'accès aux données \\
\hline
MySQL/MariaDB & 10.4+ & Système de gestion de base de données \\
\hline
Apache & 2.4+ & Serveur web (via XAMPP) \\
\hline
\end{tabular}
\caption{Technologies Backend utilisées}
\end{table}

\subsubsection{Outils de Développement}

\begin{itemize}
    \item \faCode[regular] \textbf{Node.js} : Runtime JavaScript pour les outils de build
    \item \faCodeBranch[regular] \textbf{Git} : Contrôle de version
    \item \faTerminal[regular] \textbf{npm} : Gestionnaire de paquets
    \item \faBug[regular] \textbf{Vitest} : Framework de tests
    \item \faCheckCircle[regular] \textbf{ESLint} : Linter pour la qualité du code
\end{itemize}

\newpage
\section{Architecture Technique Détaillée}

\subsection{Architecture Générale du Système}

L'application suit une architecture en trois tiers (Three-Tier Architecture) classique, séparant clairement la présentation, la logique métier et la persistance des données.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=2cm,
    tier/.style={rectangle, draw=primaryblue, fill=primaryblue!10, thick, minimum width=8cm, minimum height=1.5cm, text centered, rounded corners},
    arrow/.style={->, >=stealth, thick, color=secondaryblue}
]
    \node[tier] (presentation) {\textbf{Couche Présentation}\\React + TypeScript + Tailwind CSS};
    \node[tier, below of=presentation] (business) {\textbf{Couche Logique Métier}\\PHP + PDO + Sessions};
    \node[tier, below of=business] (data) {\textbf{Couche Données}\\MySQL/MariaDB};
    
    \draw[arrow] (presentation) -- node[right] {Requêtes HTTP} (business);
    \draw[arrow] (business) -- node[right] {Requêtes SQL} (data);
    \draw[arrow] (data) -- node[left] {Résultats} (business);
    \draw[arrow] (business) -- node[left] {Réponses JSON} (presentation);
\end{tikzpicture}
\caption{Architecture en trois tiers de l'application}
\end{figure}

\subsection{Flux de Données}

\subsubsection{Flux de Connexion Utilisateur}

Le processus d'authentification suit un flux sécurisé en plusieurs étapes :

\begin{enumerate}
    \item \textbf{Saisie des identifiants} : L'utilisateur saisit son email et mot de passe dans le formulaire React
    \item \textbf{Validation côté client} : React Hook Form valide le format de l'email et la présence du mot de passe
    \item \textbf{Envoi de la requête} : Fetch API envoie une requête POST vers \texttt{backend/login.php} avec les credentials
    \item \textbf{Vérification serveur} : PHP vérifie l'email dans la base de données
    \item \textbf{Vérification du mot de passe} : \texttt{password\_verify()} compare le hash stocké avec le mot de passe fourni
    \item \textbf{Création de session} : Si valide, une session PHP est créée avec les données utilisateur
    \item \textbf{Régénération de session ID} : Protection contre les attaques de fixation de session
    \item \textbf{Réponse JSON} : Le serveur renvoie les données utilisateur au client
    \item \textbf{Stockage local} : React stocke les données dans \texttt{localStorage} pour la persistance
    \item \textbf{Redirection} : Navigation vers le dashboard approprié selon le rôle
\end{enumerate}

\subsubsection{Flux de Prise de Rendez-vous}

Le processus de création d'un rendez-vous implique plusieurs validations et étapes :

\begin{enumerate}
    \item \textbf{Remplissage du formulaire} : L'utilisateur (connecté ou non) remplit le formulaire de rendez-vous
    \item \textbf{Validation côté client} : 
    \begin{itemize}
        \item Vérification du format email
        \item Validation du format de téléphone français
        \item Vérification que la date n'est pas dans le passé
        \item Validation de la longueur minimale des champs requis
    \end{itemize}
    \item \textbf{Envoi des données} : FormData est envoyé via POST vers \texttt{backend/appointment.php}
    \item \textbf{Validation serveur} : PHP valide à nouveau tous les champs (sécurité renforcée)
    \item \textbf{Construction de la date} : Combinaison de la date et de l'heure en format DATETIME
    \item \textbf{Vérification de session} : Si l'utilisateur est connecté, récupération de son \texttt{user\_id}
    \item \textbf{Insertion en base} : Requête SQL préparée pour insérer le rendez-vous
    \item \textbf{Confirmation} : Message de succès retourné au client
    \item \textbf{Affichage} : Interface de confirmation affichée à l'utilisateur
\end{enumerate}

\subsubsection{Flux de Récupération de l'Historique}

La fonctionnalité d'historique des rendez-vous suit un processus optimisé :

\begin{enumerate}
    \item \textbf{Chargement du Dashboard} : L'utilisateur accède à son espace personnel
    \item \textbf{Récupération de l'email} : React récupère l'email depuis \texttt{localStorage}
    \item \textbf{Requête GET} : Appel asynchrone vers \texttt{backend/user\_appointments.php?email=...}
    \item \textbf{Requête SQL} : PHP exécute une requête SELECT avec filtre sur l'email
    \item \textbf{Tri par date} : Les résultats sont triés par date décroissante (plus récents en premier)
    \item \textbf{Réponse JSON} : Tableau de rendez-vous retourné au client
    \item \textbf{Formatage des dates} : JavaScript formate les dates en français
    \item \textbf{Affichage conditionnel} : Chaque rendez-vous est affiché avec badge "À venir" ou "Passé"
    \item \textbf{Message vide} : Si aucun rendez-vous, affichage d'un message approprié
\end{enumerate}

\newpage
\section{Architecture de la Base de Données}

\subsection{Conception et Modélisation}

La base de données a été conçue selon les principes de normalisation (forme normale 3NF) pour éviter la redondance des données et garantir l'intégrité référentielle. Le schéma relationnel permet une gestion efficace des relations entre utilisateurs, rendez-vous et contacts.

\subsection{Schéma Entité-Relation}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    entity/.style={rectangle, draw=primaryblue, fill=primaryblue!10, thick, minimum width=4cm, minimum height=2cm, text centered, rounded corners},
    relation/.style={diamond, draw=secondaryblue, fill=secondaryblue!10, thick, minimum width=1.5cm, minimum height=1cm, text centered},
    arrow/.style={->, >=stealth, thick}
]
    \node[entity] (users) at (0,0) {\textbf{USERS}\\[0.3cm]id (PK)\\[0.1cm]full\_name\\email\\password\\role\\created\_at};
    
    \node[entity] (appointments) at (6,0) {\textbf{APPOINTMENTS}\\[0.3cm]id (PK)\\[0.1cm]user\_id (FK)\\[0.1cm]name\\email\\phone\\appointment\_date\\message};
    
    \node[entity] (contacts) at (3,-4) {\textbf{CONTACTS}\\[0.3cm]id (PK)\\[0.1cm]user\_id (FK)\\[0.1cm]name\\email\\message\\created\_at};
    
    \draw[arrow] (users) -- node[above] {1} node[below] {0..n} (appointments);
    \draw[arrow] (users) -- node[left] {1} node[right] {0..n} (contacts);
\end{tikzpicture}
\caption{Schéma Entité-Relation de la base de données}
\end{figure}

\subsection{Description Détaillée des Tables}

\subsubsection{Table \texttt{users} - Gestion des Utilisateurs}

Cette table constitue le cœur du système d'authentification et de gestion des utilisateurs. Elle stocke toutes les informations nécessaires pour identifier et authentifier les utilisateurs du système.

\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|p{5cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Contraintes} & \textbf{Valeur Par Défaut} & \textbf{Description Détaillée} \\
\hline
\texttt{id} & INT UNSIGNED & PRIMARY KEY, AUTO\_INCREMENT & - & Identifiant unique auto-incrémenté. Clé primaire de la table. \\
\hline
\texttt{full\_name} & VARCHAR(150) & NOT NULL & - & Nom complet de l'utilisateur. Stocke le prénom et nom concaténés. \\
\hline
\texttt{email} & VARCHAR(255) & NOT NULL, UNIQUE & - & Adresse email unique. Utilisée pour l'authentification et comme identifiant unique. Index unique créé automatiquement. \\
\hline
\texttt{password} & VARCHAR(255) & NOT NULL & - & Mot de passe hashé avec bcrypt. La longueur de 255 caractères permet de stocker les hashs générés par \texttt{password\_hash()} de PHP. \\
\hline
\texttt{role} & ENUM('user','admin') & NOT NULL & 'user' & Rôle de l'utilisateur. 'user' pour les patients, 'admin' pour les administrateurs. Contrôle l'accès aux fonctionnalités. \\
\hline
\texttt{created\_at} & TIMESTAMP & NOT NULL & CURRENT\_TIMESTAMP & Date et heure de création du compte. Automatiquement rempli lors de l'insertion. \\
\hline
\end{tabular}%
}
\caption{Structure détaillée de la table \texttt{users}}
\end{table}

\textbf{Index et Performance :}
\begin{itemize}
    \item Index primaire sur \texttt{id} pour les jointures rapides
    \item Index unique sur \texttt{email} pour les recherches d'authentification optimisées
    \item Le type ENUM pour \texttt{role} garantit l'intégrité des données
\end{itemize}

\subsubsection{Table \texttt{appointments} - Gestion des Rendez-vous}

Cette table stocke tous les rendez-vous pris par les patients, qu'ils soient connectés ou non. La relation avec \texttt{users} est optionnelle pour permettre les rendez-vous de visiteurs non inscrits.

\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|p{5cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Contraintes} & \textbf{Description Détaillée} \\
\hline
\texttt{id} & INT UNSIGNED & PRIMARY KEY, AUTO\_INCREMENT & Identifiant unique du rendez-vous. Clé primaire. \\
\hline
\texttt{user\_id} & INT UNSIGNED & FOREIGN KEY, NULLABLE & Référence optionnelle vers \texttt{users.id}. NULL si le rendez-vous est pris par un visiteur non connecté. Permet de lier les rendez-vous aux comptes utilisateurs. \\
\hline
\texttt{name} & VARCHAR(150) & NOT NULL & Nom complet du patient. Stocké même si l'utilisateur est connecté pour préserver l'historique. \\
\hline
\texttt{email} & VARCHAR(255) & NOT NULL & Email du patient. Utilisé pour la recherche d'historique. Permet de retrouver tous les rendez-vous d'un email donné. \\
\hline
\texttt{phone} & VARCHAR(30) & NOT NULL & Numéro de téléphone du patient. Format flexible pour accepter différents formats internationaux. \\
\hline
\texttt{appointment\_date} & DATETIME & NOT NULL & Date et heure complète du rendez-vous. Format : YYYY-MM-DD HH:MM:SS. Permet le tri chronologique et les filtres par date. \\
\hline
\texttt{message} & TEXT & NULLABLE & Message optionnel du patient. Peut contenir des informations supplémentaires sur le motif de consultation ou des demandes spéciales. \\
\hline
\end{tabular}%
}
\caption{Structure détaillée de la table \texttt{appointments}}
\end{table}

\textbf{Contraintes et Relations :}
\begin{itemize}
    \item Clé étrangère \texttt{user\_id} → \texttt{users.id} avec \texttt{ON DELETE SET NULL} : Si un utilisateur est supprimé, ses rendez-vous restent mais perdent la référence
    \item \texttt{ON UPDATE CASCADE} : Si l'ID utilisateur change, les références sont mises à jour
    \item L'email est stocké même pour les utilisateurs connectés pour permettre la recherche d'historique par email
\end{itemize}

\textbf{Requêtes Optimisées :}
\begin{lstlisting}[style=sqlstyle, caption=Index recommandé pour optimiser les recherches]
CREATE INDEX idx_appointments_email ON appointments(email);
CREATE INDEX idx_appointments_date ON appointments(appointment_date);
CREATE INDEX idx_appointments_user_id ON appointments(user_id);
\end{lstlisting}

\subsubsection{Table \texttt{contacts} - Messages de Contact}

Cette table stocke tous les messages envoyés via le formulaire de contact du site web.

\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|p{5cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Contraintes} & \textbf{Description Détaillée} \\
\hline
\texttt{id} & INT UNSIGNED & PRIMARY KEY, AUTO\_INCREMENT & Identifiant unique du message. Clé primaire. \\
\hline
\texttt{user\_id} & INT UNSIGNED & FOREIGN KEY, NULLABLE & Référence optionnelle vers \texttt{users.id}. NULL si le message provient d'un visiteur non connecté. \\
\hline
\texttt{name} & VARCHAR(150) & NOT NULL & Nom du contact. Informations de base pour identifier l'expéditeur. \\
\hline
\texttt{email} & VARCHAR(255) & NOT NULL & Email du contact. Permet de répondre au message. \\
\hline
\texttt{message} & TEXT & NOT NULL & Contenu du message. Type TEXT pour permettre des messages longs. Validation minimale de 10 caractères côté serveur. \\
\hline
\texttt{created\_at} & TIMESTAMP & NOT NULL & CURRENT\_TIMESTAMP & Date et heure d'envoi du message. Permet le tri chronologique et le suivi des messages récents. \\
\hline
\end{tabular}%
}
\caption{Structure détaillée de la table \texttt{contacts}}
\end{table}

\subsection{Relations et Intégrité Référentielle}

\subsubsection{Relation Users → Appointments}

\begin{itemize}
    \item \textbf{Cardinalité} : Un utilisateur peut avoir zéro, un ou plusieurs rendez-vous (1:N)
    \item \textbf{Clé étrangère} : \texttt{appointments.user\_id} référence \texttt{users.id}
    \item \textbf{Comportement} : 
    \begin{itemize}
        \item \texttt{ON DELETE SET NULL} : Si un utilisateur est supprimé, ses rendez-vous conservent toutes leurs informations mais perdent la référence utilisateur
        \item \texttt{ON UPDATE CASCADE} : Si l'ID utilisateur change (rare), les références sont automatiquement mises à jour
    \end{itemize}
    \item \textbf{NULL autorisé} : Permet de stocker des rendez-vous de visiteurs non inscrits
\end{itemize}

\subsubsection{Relation Users → Contacts}

\begin{itemize}
    \item \textbf{Cardinalité} : Un utilisateur peut avoir zéro, un ou plusieurs messages de contact (1:N)
    \item \textbf{Clé étrangère} : \texttt{contacts.user\_id} référence \texttt{users.id}
    \item \textbf{Comportement} : Identique à la relation avec appointments
    \item \textbf{NULL autorisé} : Permet de stocker des messages de visiteurs anonymes
\end{itemize}

\subsection{Stratégie de Recherche d'Historique}

La fonctionnalité d'historique des rendez-vous utilise une stratégie de recherche basée sur l'email plutôt que sur \texttt{user\_id} pour plusieurs raisons :

\begin{enumerate}
    \item \textbf{Compatibilité} : Permet de retrouver les rendez-vous même si l'utilisateur n'était pas connecté lors de la prise de rendez-vous
    \item \textbf{Flexibilité} : Un utilisateur peut avoir pris des rendez-vous avant de créer son compte
    \item \textbf{Simplicité} : L'email est un identifiant naturel et mémorable
    \item \textbf{Cohérence} : Garantit que tous les rendez-vous d'un même email sont retrouvés, même si le compte a été supprimé et recréé
\end{enumerate}

\textbf{Requête SQL Optimisée :}

\begin{lstlisting}[style=sqlstyle, caption=Requête optimisée pour l'historique avec index]
SELECT 
    id,
    name,
    email,
    phone,
    appointment_date,
    message,
    CASE 
        WHEN appointment_date >= NOW() THEN 'À venir'
        ELSE 'Passé'
    END AS status
FROM appointments
WHERE email = :email
ORDER BY appointment_date DESC
LIMIT 100;
\end{lstlisting}

Cette requête utilise l'index sur \texttt{email} pour une recherche rapide et limite les résultats à 100 pour éviter les surcharges.

\newpage
\section{Fonctionnalités Détaillées}

\subsection{Système d'Authentification Complet}

\subsubsection{Inscription Utilisateur}

Le processus d'inscription implique plusieurs validations et transformations de données :

\textbf{Étapes du Processus :}

\begin{enumerate}
    \item \textbf{Réception des données} : Le formulaire React envoie \texttt{first\_name}, \texttt{last\_name}, \texttt{email} et \texttt{password}
    \item \textbf{Validation côté client} : 
    \begin{itemize}
        \item Vérification que tous les champs requis sont remplis
        \item Validation du format email avec regex
        \item Vérification de la longueur minimale du mot de passe (8 caractères)
        \item Vérification de la complexité (majuscule, minuscule, chiffre)
        \item Vérification que les deux mots de passe correspondent
    \end{itemize}
    \item \textbf{Envoi au serveur} : FormData envoyé via POST vers \texttt{backend/register.php}
    \item \textbf{Validation serveur} : 
    \begin{itemize}
        \item Vérification de la présence de tous les champs
        \item Validation du format email avec \texttt{filter\_var()}
        \item Vérification de la longueur minimale du mot de passe
    \end{itemize}
    \item \textbf{Vérification d'unicité} : Requête SQL pour vérifier que l'email n'existe pas déjà
    \item \textbf{Construction du nom complet} : Concaténation de \texttt{first\_name} et \texttt{last\_name}
    \item \textbf{Hashage du mot de passe} : Utilisation de \texttt{password\_hash()} avec l'algorithme par défaut (bcrypt)
    \item \textbf{Insertion en base} : Requête préparée pour insérer le nouvel utilisateur avec rôle 'user' par défaut
    \item \textbf{Confirmation} : Message de succès retourné au client
\end{enumerate}

\textbf{Code Complet d'Inscription :}

\begin{lstlisting}[style=phpstyle, caption=Code complet de register.php]
header('Content-Type: application/json; charset=utf-8');

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    echo json_encode([
        'success' => false,
        'message' => 'Méthode HTTP non autorisée. Utilisez POST.'
    ]);
    exit;
}

require_once __DIR__ . '/config.php';

function send_error(string $message, int $statusCode = 400): void
{
    http_response_code($statusCode);
    echo json_encode([
        'success' => false,
        'message' => $message,
    ]);
    exit;
}

$firstName = isset($_POST['first_name']) ? trim($_POST['first_name']) : '';
$lastName  = isset($_POST['last_name']) ? trim($_POST['last_name']) : '';
$email     = isset($_POST['email']) ? trim($_POST['email']) : '';
$password  = isset($_POST['password']) ? (string)$_POST['password'] : '';

$errors = [];

if ($firstName === '') {
    $errors['first_name'] = 'Le prénom est requis.';
}

if ($lastName === '') {
    $errors['last_name'] = 'Le nom est requis.';
}

if ($email === '') {
    $errors['email'] = 'L\'adresse email est requise.';
} elseif (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
    $errors['email'] = 'L\'adresse email n\'est pas valide.';
}

if ($password === '') {
    $errors['password'] = 'Le mot de passe est requis.';
} elseif (strlen($password) < 8) {
    $errors['password'] = 'Le mot de passe doit contenir au moins 8 caractères.';
}

if (!empty($errors)) {
    send_error('Certains champs sont invalides.', 422);
}

$fullName = $firstName . ' ' . $lastName;

try {
    $pdo = getPDO();

    $stmt = $pdo->prepare('SELECT id FROM users WHERE email = :email LIMIT 1');
    $stmt->execute([':email' => $email]);

    if ($stmt->fetch()) {
        send_error('Cette adresse email est déjà utilisée.', 409);
    }

    $passwordHash = password_hash($password, PASSWORD_DEFAULT);

    $insert = $pdo->prepare('
        INSERT INTO users (full_name, email, password, role)
        VALUES (:full_name, :email, :password, :role)
    ');

    $insert->execute([
        ':full_name' => $fullName,
        ':email'     => $email,
        ':password'  => $passwordHash,
        ':role'      => 'user',
    ]);

    echo json_encode([
        'success' => true,
        'message' => 'Inscription réussie. Vous pouvez maintenant vous connecter.',
    ]);
} catch (PDOException $e) {
    http_response_code(500);
    echo json_encode([
        'success' => false,
        'message' => 'Une erreur interne est survenue lors de l\'inscription.',
    ]);
}
\end{lstlisting}

\textbf{Sécurité du Hashage :}

Le mot de passe est hashé avec \texttt{password\_hash()} qui utilise par défaut l'algorithme bcrypt avec un coût de 10. Cela signifie :
\begin{itemize}
    \item Le hash généré fait environ 60 caractères
    \item Chaque hash est unique grâce au salt automatique
    \item Le coût de calcul rend les attaques par force brute très lentes
    \item Compatible avec \texttt{password\_verify()} pour la vérification
\end{itemize}

\subsubsection{Connexion et Gestion de Session}

Le processus de connexion implique plusieurs vérifications de sécurité :

\textbf{Mécanisme de Vérification :}

\begin{lstlisting}[style=phpstyle, caption=Processus complet de connexion]
$stmt = $pdo->prepare('
    SELECT id, full_name, email, password, role 
    FROM users 
    WHERE email = :email 
    LIMIT 1
');
$stmt->execute([':email' => $email]);
$user = $stmt->fetch();

if (!$user) {
    login_error('Identifiants incorrects.', 401);
}

if (!password_verify($password, $user['password'])) {
    login_error('Identifiants incorrects.', 401);
}

if (session_status() !== PHP_SESSION_ACTIVE) {
    session_start();
}

$_SESSION['user_id'] = (int)$user['id'];
$_SESSION['full_name'] = $user['full_name'];
$_SESSION['user_email'] = $user['email'];
$_SESSION['role'] = $user['role'] ?? 'user';

session_regenerate_id(true);
\end{lstlisting}

\textbf{Mesures de Sécurité :}

\begin{itemize}
    \item \textbf{Message générique} : Même message d'erreur pour email inexistant ou mot de passe incorrect (protection contre l'énumération)
    \item \textbf{Requête préparée} : Protection contre les injections SQL
    \item \textbf{Régénération de session ID} : Protection contre les attaques de fixation de session
    \item \textbf{Stockage minimal} : Seules les données nécessaires sont stockées en session
    \item \textbf{Validation du rôle} : Vérification du rôle pour contrôler l'accès
\end{itemize}

\subsection{Gestion Avancée des Rendez-vous}

\subsubsection{Création de Rendez-vous avec Validation Complète}

Le processus de création implique plusieurs validations et transformations :

\textbf{Validations Côté Client (React) :}

\begin{lstlisting}[style=jsstyle, caption=Validation complète du formulaire de rendez-vous]
const validateForm = (): boolean => {
    const newErrors: FormErrors = {};

    if (!formData.fullName.trim()) {
        newErrors.fullName = "Le nom complet est requis";
    } else if (formData.fullName.trim().length < 2) {
        newErrors.fullName = "Le nom doit contenir au moins 2 caractères";
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!formData.email.trim()) {
        newErrors.email = "L'adresse email est requise";
    } else if (!emailRegex.test(formData.email)) {
        newErrors.email = "Veuillez entrer une adresse email valide";
    }

    const phoneRegex = /^(?:(?:\+|00)33|0)\s*[1-9](?:[\s.-]*\d{2}){4}$/;
    if (!formData.phone.trim()) {
        newErrors.phone = "Le numéro de téléphone est requis";
    } else if (!phoneRegex.test(formData.phone.replace(/\s/g, ""))) {
        newErrors.phone = "Veuillez entrer un numéro de téléphone français valide";
    }

    if (!formData.date) {
        newErrors.date = "Veuillez sélectionner une date";
    } else {
        const selectedDate = new Date(formData.date);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        if (selectedDate < today) {
            newErrors.date = "La date ne peut pas être dans le passé";
        }
    }

    if (!formData.service) {
        newErrors.service = "Veuillez sélectionner un service";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
};
\end{lstlisting}

\textbf{Traitement Serveur :}

\begin{lstlisting}[style=phpstyle, caption=Traitement complet côté serveur]
$name    = isset($_POST['name']) ? trim($_POST['name']) : '';
$email   = isset($_POST['email']) ? trim($_POST['email']) : '';
$phone   = isset($_POST['phone']) ? trim($_POST['phone']) : '';
$date    = isset($_POST['date']) ? trim($_POST['date']) : '';
$time    = isset($_POST['time']) ? trim($_POST['time']) : '';
$message = isset($_POST['message']) ? trim($_POST['message']) : '';

$errors = [];

if ($name === '') {
    $errors['name'] = 'Le nom est requis.';
}

if ($email === '') {
    $errors['email'] = 'L\'adresse email est requise.';
} elseif (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
    $errors['email'] = 'L\'adresse email n\'est pas valide.';
}

if ($phone === '') {
    $errors['phone'] = 'Le numéro de téléphone est requis.';
}

if ($date === '') {
    $errors['date'] = 'La date du rendez-vous est requise.';
}

if (!empty($errors)) {
    appointment_error('Certains champs sont invalides.', $errors, 422);
}

if ($time !== '') {
    $appointmentDateTime = $date . ' ' . $time . ':00';
} else {
    $appointmentDateTime = $date . ' 09:00:00';
}

$dt = DateTime::createFromFormat('Y-m-d H:i:s', $appointmentDateTime);
if (!$dt || $dt->format('Y-m-d H:i:s') !== $appointmentDateTime) {
    $errors['date'] = 'La date/heure du rendez-vous est invalide.';
}

if (!empty($errors)) {
    appointment_error('Certains champs sont invalides.', $errors, 422);
}

$userId = isset($_SESSION['user_id']) ? (int)$_SESSION['user_id'] : null;

try {
    $pdo = getPDO();

    $stmt = $pdo->prepare('
        INSERT INTO appointments (user_id, name, email, phone, appointment_date, message)
        VALUES (:user_id, :name, :email, :phone, :appointment_date, :message)
    ');

    $stmt->execute([
        ':user_id'          => $userId,
        ':name'             => $name,
        ':email'            => $email,
        ':phone'            => $phone,
        ':appointment_date' => $appointmentDateTime,
        ':message'          => $message,
    ]);

    echo json_encode([
        'success' => true,
        'message' => 'Votre demande de rendez-vous a été enregistrée avec succès.',
    ]);
} catch (PDOException $e) {
    http_response_code(500);
    echo json_encode([
        'success' => false,
        'message' => 'Une erreur interne est survenue lors de l\'enregistrement du rendez-vous.',
    ]);
}
\end{lstlisting}

\subsubsection{Fonctionnalité d'Historique des Rendez-vous}

Cette fonctionnalité est l'une des plus importantes du projet. Elle permet aux utilisateurs de consulter automatiquement tous leurs rendez-vous passés et à venir.

\textbf{Endpoint Backend :}

\begin{lstlisting}[style=phpstyle, caption=Endpoint complet user_appointments.php]
<?php
header('Content-Type: application/json; charset=utf-8');

if (session_status() !== PHP_SESSION_ACTIVE) {
    session_start();
}

require_once __DIR__ . '/config.php';

if ($_SERVER['REQUEST_METHOD'] !== 'GET') {
    http_response_code(405);
    echo json_encode([
        'success' => false,
        'message' => 'Méthode HTTP non autorisée. Utilisez GET.'
    ]);
    exit;
}

$email = isset($_GET['email']) ? trim($_GET['email']) : '';

if ($email === '') {
    http_response_code(400);
    echo json_encode([
        'success' => false,
        'message' => 'L\'adresse email est requise.'
    ]);
    exit;
}

if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
    http_response_code(422);
    echo json_encode([
        'success' => false,
        'message' => 'L\'adresse email n\'est pas valide.'
    ]);
    exit;
}

try {
    $pdo = getPDO();

    $stmt = $pdo->prepare('
        SELECT 
            id,
            name,
            email,
            phone,
            appointment_date,
            message
        FROM appointments
        WHERE email = :email
        ORDER BY appointment_date DESC
    ');

    $stmt->execute([':email' => $email]);

    $appointments = $stmt->fetchAll();

    echo json_encode([
        'success' => true,
        'appointments' => $appointments,
        'count' => count($appointments)
    ]);
} catch (PDOException $e) {
    http_response_code(500);
    echo json_encode([
        'success' => false,
        'message' => 'Une erreur interne est survenue lors de la récupération des rendez-vous.',
    ]);
}
\end{lstlisting}

\textbf{Intégration Frontend Complète :}

\begin{lstlisting}[style=jsstyle, caption=Code complet du Dashboard avec historique]
import { useEffect, useMemo, useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import Layout from "@/components/Layout";
import { Button } from "@/components/ui/button";
import { Calendar, Clock, Phone, Mail, MessageSquare } from "lucide-react";

type StoredUser = {
  id: number;
  full_name: string;
  email: string;
};

type Appointment = {
  id: number;
  name: string;
  email: string;
  phone: string;
  appointment_date: string;
  message: string | null;
};

const STORAGE_KEY = "bss_user";

const Dashboard = () => {
  const navigate = useNavigate();
  const [user, setUser] = useState<StoredUser | null>(null);
  const [isLoggingOut, setIsLoggingOut] = useState(false);
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [loadingAppointments, setLoadingAppointments] = useState(true);

  const apiBase = useMemo(() => import.meta.env.BASE_URL, []);

  useEffect(() => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      navigate("/login", { replace: true });
      return;
    }
    try {
      const parsedUser = JSON.parse(raw) as StoredUser;
      setUser(parsedUser);
    } catch {
      localStorage.removeItem(STORAGE_KEY);
      navigate("/login", { replace: true });
    }
  }, [navigate]);

  useEffect(() => {
    if (!user?.email) return;

    const loadAppointments = async () => {
      setLoadingAppointments(true);
      try {
        const response = await fetch(
          `${apiBase}backend/user_appointments.php?email=${
            encodeURIComponent(user.email)
          }`,
          {
            method: "GET",
            credentials: "include",
          }
        );

        const data = (await response.json()) as {
          success: boolean;
          appointments?: Appointment[];
          message?: string;
        };

        if (data.success && data.appointments) {
          setAppointments(data.appointments);
        }
      } catch (error) {
        console.error("Erreur lors du chargement des rendez-vous:", error);
      } finally {
        setLoadingAppointments(false);
      }
    };

    loadAppointments();
  }, [user?.email, apiBase]);

  const handleLogout = async () => {
    setIsLoggingOut(true);
    try {
      await fetch(`${apiBase}backend/logout.php`, {
        method: "POST",
        credentials: "include",
      });
    } finally {
      localStorage.removeItem(STORAGE_KEY);
      setIsLoggingOut(false);
      navigate("/", { replace: true });
    }
  };

  if (!user) return null;

  return (
    <Layout>
      <section className="section-padding bg-muted">
        <div className="container mx-auto px-4">
          <div className="max-w-3xl mx-auto">
            <div className="bg-card rounded-2xl p-8 shadow-dental">
              <h1 className="font-display text-3xl font-bold text-foreground">
                Espace patient
              </h1>
              <p className="text-muted-foreground mt-2">
                Bienvenue <span className="font-medium text-foreground">{user.full_name}</span>.
              </p>

              <div className="mt-6 grid gap-4 md:grid-cols-2">
                <div className="rounded-xl border border-border bg-background p-5">
                  <h2 className="font-display text-lg font-semibold text-foreground">
                    Informations
                  </h2>
                  <div className="mt-3 space-y-1 text-sm">
                    <p className="text-muted-foreground">
                      <span className="font-medium text-foreground">Email:</span> {user.email}
                    </p>
                    <p className="text-muted-foreground">
                      <span className="font-medium text-foreground">ID:</span> {user.id}
                    </p>
                  </div>
                </div>

                <div className="rounded-xl border border-border bg-background p-5">
                  <h2 className="font-display text-lg font-semibold text-foreground">
                    Actions rapides
                  </h2>
                  <div className="mt-4 flex flex-col gap-3">
                    <Button asChild size="lg">
                      <Link to="/appointment">Prendre un rendez-vous</Link>
                    </Button>
                    <Button asChild variant="outline" size="lg">
                      <Link to="/contact">Contacter le cabinet</Link>
                    </Button>
                    <Button
                      variant="secondary"
                      size="lg"
                      onClick={handleLogout}
                      disabled={isLoggingOut}
                    >
                      {isLoggingOut ? "Déconnexion..." : "Se déconnecter"}
                    </Button>
                  </div>
                </div>
              </div>

              {appointments.length > 0 && (
                <div className="mt-8">
                  <h2 className="font-display text-xl font-semibold text-foreground mb-4">
                    Historique de vos rendez-vous ({appointments.length})
                  </h2>
                  <div className="space-y-4">
                    {appointments.map((appointment) => {
                      const appointmentDate = new Date(appointment.appointment_date);
                      const formattedDate = appointmentDate.toLocaleDateString("fr-FR", {
                        weekday: "long",
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                      });
                      const formattedTime = appointmentDate.toLocaleTimeString("fr-FR", {
                        hour: "2-digit",
                        minute: "2-digit",
                      });

                      return (
                        <div
                          key={appointment.id}
                          className="rounded-xl border border-border bg-background p-5 hover:shadow-md transition-shadow"
                        >
                          <div className="flex items-start justify-between gap-4">
                            <div className="flex-1">
                              <div className="flex items-center gap-2 mb-2">
                                <Calendar className="w-5 h-5 text-primary" />
                                <h3 className="font-display text-lg font-semibold text-foreground">
                                  Rendez-vous #{appointment.id}
                                </h3>
                              </div>
                              <div className="space-y-2 text-sm">
                                <div className="flex items-center gap-2 text-muted-foreground">
                                  <Clock className="w-4 h-4" />
                                  <span>
                                    {formattedDate} à {formattedTime}
                                  </span>
                                </div>
                                <div className="flex items-center gap-2 text-muted-foreground">
                                  <Phone className="w-4 h-4" />
                                  <span>{appointment.phone}</span>
                                </div>
                                <div className="flex items-center gap-2 text-muted-foreground">
                                  <Mail className="w-4 h-4" />
                                  <span>{appointment.email}</span>
                                </div>
                                {appointment.message && (
                                  <div className="flex items-start gap-2 text-muted-foreground mt-3 pt-3 border-t border-border">
                                    <MessageSquare className="w-4 h-4 mt-0.5" />
                                    <span className="flex-1">{appointment.message}</span>
                                  </div>
                                )}
                              </div>
                            </div>
                            <div className="text-right">
                              <span
                                className={`inline-block px-3 py-1 rounded-full text-xs font-medium ${
                                  appointmentDate >= new Date()
                                    ? "bg-primary/10 text-primary"
                                    : "bg-muted text-muted-foreground"
                                }`}
                              >
                                {appointmentDate >= new Date() ? "À venir" : "Passé"}
                              </span>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {!loadingAppointments && appointments.length === 0 && (
                <div className="mt-8 rounded-xl border border-border bg-background p-8 text-center">
                  <Calendar className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
                  <p className="text-muted-foreground">
                    Vous n'avez pas encore de rendez-vous enregistré.
                  </p>
                  <Button asChild className="mt-4">
                    <Link to="/appointment">Prendre un rendez-vous</Link>
                  </Button>
                </div>
              )}

              {loadingAppointments && (
                <div className="mt-8 text-center">
                  <p className="text-muted-foreground">Chargement de vos rendez-vous...</p>
                </div>
              )}
            </div>
          </div>
        </div>
      </section>
    </Layout>
  );
};

export default Dashboard;
\end{lstlisting}

\textbf{Formatage des Dates :}

Le formatage des dates en français utilise l'API Intl de JavaScript :

\begin{itemize}
    \item \texttt{toLocaleDateString("fr-FR")} : Formate la date selon les conventions françaises
    \item Options de formatage : jour de la semaine, année complète, mois en lettres, jour numérique
    \item \texttt{toLocaleTimeString("fr-FR")} : Formate l'heure au format 24h français
\end{itemize}

\newpage
\section{Interface Administrateur Complète}

\subsection{Architecture de l'Interface Admin}

L'interface administrateur est construite autour d'un système de contrôle d'accès basé sur les rôles (RBAC - Role-Based Access Control). Seuls les utilisateurs avec le rôle 'admin' peuvent accéder à cette interface.

\subsubsection{Système de Protection}

\begin{lstlisting}[style=phpstyle, caption=Système complet de protection admin]
<?php
header('Content-Type: application/json; charset=utf-8');

require_once __DIR__ . '/../config.php';

function ensure_session(): void
{
    if (session_status() !== PHP_SESSION_ACTIVE) {
        session_start();
    }
}

function require_admin(): void
{
    ensure_session();

    $role = $_SESSION['role'] ?? 'user';
    if ($role !== 'admin') {
        http_response_code(403);
        echo json_encode([
            'success' => false,
            'message' => 'Accès refusé. Administrateur requis.',
        ]);
        exit;
    }
}
\end{lstlisting}

\subsection{Gestion CRUD Complète}

\subsubsection{Opérations sur les Utilisateurs}

\textbf{Création d'Utilisateur :}

\begin{lstlisting}[style=phpstyle, caption=Création d'utilisateur par l'admin]
case 'create':
    $fullName = trim($_POST['full_name'] ?? '');
    $email    = trim($_POST['email'] ?? '');
    $password = (string)($_POST['password'] ?? '');
    $role     = $_POST['role'] ?? 'user';

    if ($fullName === '' || $email === '' || $password === '') {
        http_response_code(422);
        echo json_encode(['success' => false, 'message' => 'Nom, email et mot de passe sont requis.']);
        exit;
    }

    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
        http_response_code(422);
        echo json_encode(['success' => false, 'message' => 'Email invalide.']);
        exit;
    }

    if (!in_array($role, ['user', 'admin'], true)) {
        $role = 'user';
    }

    try {
        $stmt = $pdo->prepare('SELECT id FROM users WHERE email = :email LIMIT 1');
        $stmt->execute([':email' => $email]);
        if ($stmt->fetch()) {
            http_response_code(409);
            echo json_encode(['success' => false, 'message' => 'Cette adresse email est déjà utilisée.']);
            exit;
        }

        $hash = password_hash($password, PASSWORD_DEFAULT);

        $insert = $pdo->prepare('
            INSERT INTO users (full_name, email, password, role)
            VALUES (:full_name, :email, :password, :role)
        ');
        $insert->execute([
            ':full_name' => $fullName,
            ':email'     => $email,
            ':password'  => $hash,
            ':role'      => $role,
        ]);

        echo json_encode(['success' => true, 'message' => 'Utilisateur créé avec succès.']);
    } catch (PDOException $e) {
        http_response_code(500);
        echo json_encode(['success' => false, 'message' => 'Erreur serveur lors de la création de l\'utilisateur.']);
    }
    exit;
\end{lstlisting}

\textbf{Modification d'Utilisateur :}

\begin{lstlisting}[style=phpstyle, caption=Modification d'utilisateur]
case 'update':
    $id       = isset($_POST['id']) ? (int)$_POST['id'] : 0;
    $fullName = trim($_POST['full_name'] ?? '');
    $email    = trim($_POST['email'] ?? '');
    $role     = $_POST['role'] ?? 'user';

    if ($id <= 0) {
        http_response_code(422);
        echo json_encode(['success' => false, 'message' => 'ID utilisateur invalide.']);
        exit;
    }

    if ($fullName === '' || $email === '') {
        http_response_code(422);
        echo json_encode(['success' => false, 'message' => 'Nom et email sont requis.']);
        exit;
    }

    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
        http_response_code(422);
        echo json_encode(['success' => false, 'message' => 'Email invalide.']);
        exit;
    }

    if (!in_array($role, ['user', 'admin'], true)) {
        $role = 'user';
    }

    try {
        $stmt = $pdo->prepare('SELECT id FROM users WHERE email = :email AND id <> :id LIMIT 1');
        $stmt->execute([':email' => $email, ':id' => $id]);
        if ($stmt->fetch()) {
            http_response_code(409);
            echo json_encode(['success' => false, 'message' => 'Cette adresse email est déjà utilisée.']);
            exit;
        }

        $update = $pdo->prepare('
            UPDATE users
            SET full_name = :full_name, email = :email, role = :role
            WHERE id = :id
        ');
        $update->execute([
            ':full_name' => $fullName,
            ':email'     => $email,
            ':role'      => $role,
            ':id'        => $id,
        ]);

        echo json_encode(['success' => true, 'message' => 'Utilisateur mis à jour avec succès.']);
    } catch (PDOException $e) {
        http_response_code(500);
        echo json_encode(['success' => false, 'message' => 'Erreur serveur lors de la mise à jour de l\'utilisateur.']);
    }
    exit;
\end{lstlisting}

\textbf{Suppression d'Utilisateur avec Protection :}

\begin{lstlisting}[style=phpstyle, caption=Suppression avec protection contre l'auto-suppression]
case 'delete':
    $id = isset($_POST['id']) ? (int)$_POST['id'] : 0;

    if ($id <= 0) {
        http_response_code(422);
        echo json_encode(['success' => false, 'message' => 'ID utilisateur invalide.']);
        exit;
    }

    if (isset($_SESSION['user_id']) && (int)$_SESSION['user_id'] === $id) {
        http_response_code(400);
        echo json_encode(['success' => false, 'message' => 'Vous ne pouvez pas supprimer votre propre compte administrateur.']);
        exit;
    }

    try {
        $delete = $pdo->prepare('DELETE FROM users WHERE id = :id');
        $delete->execute([':id' => $id]);

        echo json_encode(['success' => true, 'message' => 'Utilisateur supprimé avec succès.']);
    } catch (PDOException $e) {
        http_response_code(500);
        echo json_encode(['success' => false, 'message' => 'Erreur serveur lors de la suppression de l\'utilisateur.']);
    }
    exit;
\end{lstlisting}

\newpage
\section{Sécurité et Bonnes Pratiques}

\subsection{Stratégies de Sécurité Implémentées}

\subsubsection{Protection contre les Injections SQL}

Toutes les requêtes SQL utilisent des requêtes préparées avec PDO :

\begin{itemize}
    \item \textbf{Requêtes préparées} : Les paramètres sont liés de manière sécurisée
    \item \textbf{Émulation désactivée} : \texttt{PDO::ATTR\_EMULATE\_PREPARES => false} garantit l'utilisation de vraies requêtes préparées
    \item \textbf{Échappement automatique} : PDO échappe automatiquement tous les paramètres
    \item \textbf{Types stricts} : Les paramètres sont typés explicitement (int, string)
\end{itemize}

\textbf{Exemple de Protection :}

\begin{lstlisting}[style=phpstyle, caption=Exemple de requête préparée sécurisée]
$stmt = $pdo->prepare('
    SELECT id, full_name, email, password, role 
    FROM users 
    WHERE email = :email 
    LIMIT 1
');
$stmt->execute([':email' => $email]);
\end{lstlisting}

Même si \texttt{\$email} contient du code SQL malveillant comme \texttt{' OR '1'='1}, PDO le traite comme une simple chaîne de caractères et ne l'exécute pas.

\subsubsection{Hashage des Mots de Passe}

\textbf{Algorithme Utilisé :}

\begin{itemize}
    \item \textbf{Algorithme} : bcrypt (par défaut de \texttt{password\_hash()})
    \item \textbf{Coût} : 10 (2\textsuperscript{10} = 1024 itérations)
    \item \textbf{Salt} : Généré automatiquement et unique pour chaque hash
    \item \textbf{Longueur du hash} : 60 caractères
\end{itemize}

\textbf{Comparaison avec d'Anciennes Méthodes :}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Méthode} & \textbf{Sécurité} & \textbf{Statut} \\
\hline
MD5 & Très faible & \textcolor{red}{Déprécié} \\
\hline
SHA1 & Faible & \textcolor{red}{Déprécié} \\
\hline
SHA256 (sans salt) & Moyenne & \textcolor{orange}{Non recommandé} \\
\hline
bcrypt & Élevée & \textcolor{green}{Recommandé} \\
\hline
Argon2 & Très élevée & \textcolor{green}{Optimal} \\
\hline
\end{tabular}
\caption{Comparaison des méthodes de hashage}
\end{table}

\subsubsection{Validation Multi-Niveaux}

\textbf{Validation Côté Client :}

\begin{itemize}
    \item Réduit les allers-retours serveur
    \item Améliore l'expérience utilisateur avec feedback immédiat
    \item Utilise React Hook Form pour la validation en temps réel
    \item Regex pour validation de formats (email, téléphone)
\end{itemize}

\textbf{Validation Côté Serveur :}

\begin{itemize}
    \item \textbf{Nécessaire} : Ne jamais faire confiance aux données client
    \item \textbf{Complète} : Vérifie tous les champs même si validés côté client
    \item \textbf{Sanitisation} : \texttt{trim()} pour enlever les espaces
    \item \textbf{Typage} : Cast explicite des types (int, string)
    \item \textbf{Filtres PHP} : \texttt{filter\_var()} pour validation email
\end{itemize}

\subsubsection{Gestion Sécurisée des Sessions}

\begin{itemize}
    \item \textbf{Régénération d'ID} : Après chaque connexion réussie
    \item \textbf{Stockage minimal} : Seules les données essentielles en session
    \item \textbf{Vérification de rôle} : Contrôle d'accès basé sur le rôle
    \item \textbf{Timeout} : Sessions expirant après inactivité
    \item \textbf{Cookies sécurisés} : Configuration via php.ini
\end{itemize}

\newpage
\section{Architecture Frontend Détaillée}

\subsection{Structure des Composants React}

L'application React suit une architecture modulaire avec séparation claire des responsabilités :

\begin{verbatim}
src/
├── components/          # Composants réutilisables
│   ├── ui/             # Composants UI de base (shadcn/ui)
│   ├── Header.tsx      # En-tête avec navigation
│   ├── Footer.tsx      # Pied de page
│   ├── Layout.tsx      # Layout principal
│   └── NavLink.tsx     # Composant de lien de navigation
├── pages/              # Pages de l'application
│   ├── Index.tsx       # Page d'accueil
│   ├── Login.tsx       # Page de connexion
│   ├── Register.tsx    # Page d'inscription
│   ├── Dashboard.tsx   # Dashboard utilisateur
│   ├── AdminDashboard.tsx  # Dashboard admin
│   └── ...
├── hooks/              # Hooks React personnalisés
├── lib/                # Utilitaires et helpers
└── App.tsx             # Composant racine
\end{verbatim}

\subsection{Gestion d'État}

\subsubsection{État Local avec useState}

Chaque composant gère son propre état local pour les données temporaires :

\begin{lstlisting}[style=jsstyle, caption=Exemple de gestion d'état local]
const [formData, setFormData] = useState<FormData>({
    email: "",
    password: "",
});

const [errors, setErrors] = useState<FormErrors>({});
const [isSubmitting, setIsSubmitting] = useState(false);
\end{lstlisting}

\subsubsection{État Serveur avec TanStack Query}

Pour les données provenant du serveur, TanStack Query gère automatiquement :

\begin{itemize}
    \item Le cache des données
    \item La synchronisation automatique
    \item La gestion des états de chargement
    \item La gestion des erreurs
    \item La réexécution automatique des requêtes
\end{itemize}

\subsection{Routage avec React Router}

Le routage est configuré pour fonctionner sous un sous-dossier Apache :

\begin{lstlisting}[style=jsstyle, caption=Configuration du routage]
<BrowserRouter basename={import.meta.env.BASE_URL}>
    <Routes>
        <Route path="/" element={<Index />} />
        <Route path="/about" element={<About />} />
        <Route path="/services" element={<Services />} />
        <Route path="/appointment" element={<Appointment />} />
        <Route path="/contact" element={<Contact />} />
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/admin" element={<AdminDashboard />} />
        <Route path="*" element={<NotFound />} />
    </Routes>
</BrowserRouter>
\end{lstlisting}

\subsection{Styling avec Tailwind CSS}

Tailwind CSS permet un développement rapide avec des classes utilitaires :

\begin{itemize}
    \item \textbf{Responsive} : Classes \texttt{md:}, \texttt{lg:} pour le responsive design
    \item \textbf{Thème personnalisé} : Configuration dans \texttt{tailwind.config.ts}
    \item \textbf{Composants réutilisables} : Classes personnalisées pour les composants communs
    \item \textbf{Purge automatique} : Suppression du CSS non utilisé en production
\end{itemize}

\newpage
\section{Configuration et Déploiement}

\subsection{Configuration Vite}

Le fichier \texttt{vite.config.ts} configure plusieurs aspects importants :

\begin{lstlisting}[style=jsstyle, caption=Configuration Vite complète]
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

export default defineConfig(({ mode }) => ({
  base: "/bright-smile-studio/",
  build: {
    rollupOptions: {
      input: path.resolve(__dirname, "index.vite.html"),
    },
  },
  server: {
    host: "::",
    port: 8080,
    proxy: {
      "/backend": {
        target: "http://localhost",
        changeOrigin: true,
        rewrite: (p) => p.replace(/^\/backend/, "/bright-smile-studio/backend"),
      },
    },
    hmr: {
      overlay: false,
    },
  },
  plugins: [react(), mode === "development" && componentTagger()].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
\end{lstlisting}

\textbf{Explications des Options :}

\begin{itemize}
    \item \texttt{base} : URL de base pour les assets en production (sous-dossier Apache)
    \item \texttt{proxy} : Redirection des requêtes \texttt{/backend/*} vers Apache pour éviter les problèmes CORS
    \item \texttt{alias} : Permet d'utiliser \texttt{@/} au lieu de chemins relatifs
    \item \texttt{hmr} : Hot Module Replacement pour le rechargement à chaud
\end{itemize}

\subsection{Configuration Apache}

Le fichier \texttt{.htaccess} configure la réécriture d'URL pour React Router :

\begin{verbatim}
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteBase /bright-smile-studio/
    RewriteRule ^index\.html$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /bright-smile-studio/index.html [L]
</IfModule>
\end{verbatim}

Cette configuration permet à React Router de gérer toutes les routes côté client, même après un rafraîchissement de page.

\newpage
\section{Tests et Validation}

\subsection{Stratégie de Test}

\subsubsection{Tests Unitaires}

Les tests unitaires sont configurés avec Vitest :

\begin{lstlisting}[style=jsstyle, caption=Exemple de test unitaire]
import { describe, it, expect } from 'vitest';
import { validateEmail } from './utils';

describe('validateEmail', () => {
  it('devrait valider un email correct', () => {
    expect(validateEmail('test@example.com')).toBe(true);
  });

  it('devrait rejeter un email invalide', () => {
    expect(validateEmail('invalid-email')).toBe(false);
  });
});
\end{lstlisting}

\subsubsection{Validation des Formulaires}

Tous les formulaires sont validés avec Zod pour garantir la cohérence des données :

\begin{lstlisting}[style=jsstyle, caption=Schéma de validation Zod]
import { z } from 'zod';

const appointmentSchema = z.object({
  fullName: z.string().min(2, "Le nom doit contenir au moins 2 caractères"),
  email: z.string().email("Email invalide"),
  phone: z.string().regex(/^(?:(?:\+|00)33|0)\s*[1-9](?:[\s.-]*\d{2}){4}$/, "Téléphone invalide"),
  date: z.string().refine((date) => new Date(date) >= new Date(), {
    message: "La date ne peut pas être dans le passé"
  }),
  service: z.string().min(1, "Veuillez sélectionner un service"),
});
\end{lstlisting}

\newpage
\section{Performance et Optimisation}

\subsection{Optimisations Frontend}

\subsubsection{Code Splitting}

Vite effectue automatiquement le code splitting pour réduire la taille du bundle initial :

\begin{itemize}
    \item Séparation automatique des routes
    \item Chargement à la demande des composants
    \item Réduction de la taille du bundle initial
\end{itemize}

\subsubsection{Lazy Loading}

Les composants peuvent être chargés de manière paresseuse :

\begin{lstlisting}[style=jsstyle, caption=Exemple de lazy loading]
import { lazy, Suspense } from 'react';

const AdminDashboard = lazy(() => import('./pages/AdminDashboard'));

<Suspense fallback={<div>Chargement...</div>}>
    <AdminDashboard />
</Suspense>
\end{lstlisting}

\subsection{Optimisations Backend}

\subsubsection{Requêtes SQL Optimisées}

\begin{itemize}
    \item Utilisation d'index sur les colonnes fréquemment recherchées
    \item LIMIT pour limiter les résultats
    \item ORDER BY sur des colonnes indexées
    \item Éviter les SELECT * et ne récupérer que les colonnes nécessaires
\end{itemize}

\subsubsection{Connexion PDO Réutilisable}

La fonction \texttt{getPDO()} utilise un pattern Singleton pour réutiliser la connexion :

\begin{lstlisting}[style=phpstyle, caption=Pattern Singleton pour la connexion]
function getPDO(): PDO
{
    static $pdo = null;

    if ($pdo === null) {
        $dsn = 'mysql:host=' . DB_HOST . ';dbname=' . DB_NAME . ';charset=utf8mb4';

        $options = [
            PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::ATTR_EMULATE_PREPARES   => false,
        ];

        try {
            $pdo = new PDO($dsn, DB_USER, DB_PASS, $options);
        } catch (PDOException $e) {
            http_response_code(500);
            die('Erreur de connexion à la base de données.');
        }
    }

    return $pdo;
}
\end{lstlisting}

\newpage
\section{Conclusion et Perspectives}

\subsection{Bilan Technique Complet}

Le projet Bright Smile Studio représente une implémentation réussie d'une application web moderne full-stack. Les choix techniques effectués permettent une application :

\begin{itemize}
    \item \textbf{Sécurisée} : Implémentation de bonnes pratiques de sécurité à tous les niveaux
    \item \textbf{Performante} : Optimisations frontend et backend pour une expérience fluide
    \item \textbf{Maintenable} : Code structuré, typé et documenté
    \item \textbf{Évolutive} : Architecture modulaire permettant l'ajout de fonctionnalités
    \item \textbf{Moderne} : Utilisation de technologies récentes et performantes
\end{itemize}

\subsection{Fonctionnalité Clé : Historique des Rendez-vous}

La fonctionnalité d'historique des rendez-vous représente un atout majeur du projet. Elle permet :

\begin{enumerate}
    \item \textbf{Transparence totale} : Les patients voient tous leurs rendez-vous en un coup d'œil
    \item \textbf{Traçabilité} : Historique complet même pour les rendez-vous pris avant l'inscription
    \item \textbf{Confort utilisateur} : Accès rapide aux informations importantes
    \item \textbf{Réduction de la charge administrative} : Moins d'appels pour vérifier les rendez-vous
\end{enumerate}

\subsection{Perspectives d'Évolution}

\subsubsection{Améliorations Court Terme}

\begin{enumerate}
    \item \textbf{Système de notifications} : Emails automatiques de confirmation et rappels
    \item \textbf{Recherche et filtres} : Filtrage par date, statut, service dans l'historique
    \item \textbf{Export PDF} : Génération de PDF pour les rendez-vous
    \item \textbf{Calendrier visuel} : Vue calendrier pour visualiser les rendez-vous
\end{enumerate}

\subsubsection{Améliorations Moyen Terme}

\begin{enumerate}
    \item \textbf{Application mobile} : Développement d'une application React Native
    \item \textbf{Statistiques avancées} : Graphiques et analyses pour l'admin
    \item \textbf{Système de paiement} : Intégration d'un système de paiement en ligne
    \item \textbf{Chat en direct} : Support client intégré
\end{enumerate}

\subsubsection{Améliorations Long Terme}

\begin{enumerate}
    \item \textbf{IA pour suggestions} : Recommandations de créneaux optimaux
    \item \textbf{Multi-cabinet} : Support de plusieurs cabinets avec gestion centralisée
    \item \textbf{API publique} : Ouverture d'une API REST pour intégrations tierces
    \item \textbf{Microservices} : Migration vers une architecture microservices
\end{enumerate}

\subsection{Conclusion Finale}

Bright Smile Studio démontre une maîtrise complète du développement web full-stack moderne. L'application combine sécurité, performance et expérience utilisateur dans une solution complète et professionnelle.

La fonctionnalité d'historique des rendez-vous, implémentée avec une recherche basée sur l'email, garantit que les patients ont toujours accès à leur historique complet, améliorant significativement leur expérience et la transparence du service.

Le code est propre, bien structuré, et suit les meilleures pratiques de l'industrie, garantissant une maintenabilité et une évolutivité optimales pour l'avenir.

\vspace{1cm}
\noindent\textit{Document technique généré le \today}

\noindent\textit{Rapport Expert - Version 1.0}

\end{document}
